---------------------------------------------事务------------------------------------------------------
1.事务：事务是数据库中的最小执行单元是不可分割的，一个事务中拥有一条或多条sql语句，
  事务可以保证这些语句要么全部执行要么全部不执行。如果是更新语句那么必须要执行事务
  并且提交否则数据不会更新到磁盘。

2.事务可以保证多个操作原子性（注意：是多个操作的原子性），要么全成功要么全失败。对于数据库来说事务保证批量的DML  <---***---> 
  要么全成功，要么全失败。事务具有四个特征ACID:
  1)原子性（Atomicity）：事务是最小的执行单元不能分割（整个事务中的所有操作，必须作为一个单元全部完成（或全部取消））  <---***--->
  2)一致性（Consistency）：事务中可以有一条或多条sql语句，这些sql语句要么全部执行，要么全部不执行。
  3)隔离性（Isolation）：事务和事务是相互隔离的，A事务不能帮助B事务提交
  4)持久性（Durability）：执行更新语句必须使用事务提交，否则无法将数据写入磁盘，更新语句包括添加，删除，修改
  注意：
    mysql的事物是自动提交的，也就是说一条语句就是一个事务。
    rollback：回滚事务，它会将内存中所有的数据（语句）放弃，并结束当前事物释放内存。
    commit：提交事务，它会将内存中的数据序列化到磁盘中，完成数据的持久化操作，并结束当前的事物释放内存。

3.start transaction 开启一个手动的事物；

---------------------------------------事务的隔离级别-------------------------------------------------
1.不同事务隔离级别的问题  <---***--->
  1）脏读：有两个事务a和b，a事务插入了一条记录，但是并没有提交记录，这时b事务执行了一条查询语句就查询到了
           那条没有提交的数据，这条数据就是脏数据。（说白了就是读取到了内存中的数据）
  2）不可重复读：有两个事务a和b，b事务执行了一条查询语句，这时a事务执行了一条修改语句（update）并且提交了事务，
           这时b事务再一次执行刚刚的那条查询语句，2次查询结果不一样这就是不可重复读
  3）幻读：有两个事务a和b，b事务执行了一条查询语句，这时a事务执行了一条插入语句（insert）并且提交了事务，
           这时b事务再一次执行刚刚的那条查询语句，2次查询结果不一样这就是幻读

2.四个事务的隔离级别  <---***--->
  1）读未提交（read umcommitted）：可以读取到其它事务还未提交的数据，可能会出现脏读。
  2）读已提交（read committed）：只能读取到其它事务已经提交了的数据，可能会出现不可重复读或幻读。
  3）可重复读（repeatable read）：只能读取到其它事务已经提交了的数据，可以避免不可重复读但有可能会出现幻读，但是
                                  在innodb存储引擎模式中，可以避免幻读。
  4）串行化（seriallizable）[序列化]：事务完全隔离，可以避免脏读，幻读，不可重复读，但是效率也是最低的。

3.注意：根据不同事务隔离级别，去对我们的事务进行不同的控制
  例如你想要不可重复读和幻读就采用‘读已提交’事务隔离级别。
      如果你哪一种情况都不想要，可以采用‘可重复读’事务隔离级别，但如果是
      非innodb的存储引擎，只能用最后一种隔离级别。

4.查看会话级的当前隔离级别：select @@session.tx_isolation  <---***--->
  查看全局级的当前隔离级别：select @@global.tx_isolation  <---***--->
  设置事务的隔离级别：set session transaction isolation level read uncommitted;  <---***--->
      




	   